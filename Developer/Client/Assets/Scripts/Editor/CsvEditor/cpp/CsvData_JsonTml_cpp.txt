#include "stdafx.h"
#include "Data/generator/CsvData_#CLASS_NAME#.h"
namespace TopPlus
{
	CsvData_#CLASS_NAME#::CsvData_#CLASS_NAME#()
	{

	}
	//-------------------------------------------
	CsvData_#CLASS_NAME#::~CsvData_#CLASS_NAME#()
	{

	}
	//-------------------------------------------
	#GENE_FUNCS#
	//-------------------------------------------
	CsvData_#CLASS_NAME#::#JSON_CLASS_NAME#* CsvData_#CLASS_NAME#::GetData(#DATA_KEY# id)
	{
		tDataMap::iterator iter = m_mData.find( id );
		if( iter != m_mData.end() )
		{
			return iter->second;
		}
		return NULL;
	}
	//------------------------------------
	bool CsvData_#CLASS_NAME#::LoadData(const tUint8* pBuffer, int Len)
	{
		string dataBuff;
		dataBuff.assign((char*)pBuffer, Len);
		rapidjson::Document document;
		if(document.Parse(dataBuff.c_str()).HasParseError())
			return false;
		if(!document.HasMember("datas") || !document["datas"].IsArray())
			return false;

		const rapidjson::Value& datas = document["datas"];
		int len = (int)datas.Size();
		for(int i =0; i < len; ++i)
		{
			#JSON_CLASS_NAME#* data = new #JSON_CLASS_NAME#();
			
			#PARSE_FIELD#
			
			m_mData.insert(::make_pair(#USE_KEY#, data));
		}		
		
        return true;		
	}
    //-------------------------------------------
    bool CsvData_#CLASS_NAME#::LoadData(const string& strContext)
    {
		tUint8* pBuff;
		size_t nLen;
		if(!KsNS::FileSystem::Ins()->LoadFile(strContext.c_str(), pBuff, nLen))
		{
			return false;
		}
		bool bOk = LoadData(pBuff, (int)nLen);
		SAFE_DELETE_ARRAY(pBuff);
		return bOk;
    }
	//-------------------------------------------
	void CsvData_#CLASS_NAME#::Initialize(void)
	{

	}	
	//-------------------------------------------
    void CsvData_#CLASS_NAME#::ClearData()
    {
		for(tDataMap::iterator iter = m_mData.begin(); iter != m_mData.end(); ++iter)
			SAFE_DELETE(iter->second);
		m_mData.clear();
    }
}