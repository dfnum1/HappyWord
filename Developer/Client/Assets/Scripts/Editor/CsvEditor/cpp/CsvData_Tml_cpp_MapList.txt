#include "stdafx.h"
#include "Data/generator/CsvData_#CLASS_NAME#.h"
#include "Data/CsvParser.h"
namespace TopPlus
{
	CsvData_#CLASS_NAME#::CsvData_#CLASS_NAME#()
	{

	}
	//-------------------------------------------
	CsvData_#CLASS_NAME#::~CsvData_#CLASS_NAME#()
	{

	}
	//-------------------------------------------
	#GENE_FUNCS#
	//-------------------------------------------
	const vector<CsvData_#CLASS_NAME#::#CLASS_NAME#Data*>* CsvData_#CLASS_NAME#::GetData(#DATA_KEY# id)
	{
		tDataMap::iterator iter = m_mData.find( id );
		if( iter != m_mData.end() )
		{
			return &iter->second;
		}
		return NULL;
	}
	//------------------------------------
	bool CsvData_#CLASS_NAME#::LoadData(const tUint8* pBuffer, int Len)
	{
		CsvParser csv;
		if(!csv.LoadTable(pBuffer, Len))
			return false;
		
		ClearData();
		
		int i = csv.GetTitleLine();
		if(i < 0) return false;
		
		int nLineCnt = csv.GetLineCount();
		for(i++; i < nLineCnt; i++)
		{
			if(!csv[i]["#PROP_KEY#"].IsValid()) continue;
			
			#CLASS_NAME#Data* data = new #CLASS_NAME#Data();
			
			#PARSE_FIELD#
			
			if(m_mData.find(#USE_KEY#) != m_mData.end())
				m_mData[#USE_KEY#].push_back(data);
			else
			{
				vector<#CLASS_NAME#Data*> vList;
				vList.push_back(data);
				m_mData.insert(::make_pair(#USE_KEY#, vList));
			}
		}
		
        return true;		
	}
    //-------------------------------------------
    bool CsvData_#CLASS_NAME#::LoadData(const string& strContext)
    {
		CsvParser csv;
		if(!csv.LoadTableFile(strContext))
			return false;
		
		ClearData();
		
		int i = csv.GetTitleLine();
		if(i < 0) return false;
		
		int nLineCnt = csv.GetLineCount();
		for(i++; i < nLineCnt; i++)
		{
			if(!csv[i]["#PROP_KEY#"].IsValid()) continue;
			
			#CLASS_NAME#Data* data = new #CLASS_NAME#Data();
			
			#PARSE_FIELD#
			
			if(m_mData.find(#USE_KEY#) != m_mData.end())
				m_mData[#USE_KEY#].push_back(data);
			else
			{
				vector<#CLASS_NAME#Data*> vList;
				vList.push_back(data);
				m_mData.insert(::make_pair(#USE_KEY#, vList));
			}
		}
		
        return true;
    }
	//-------------------------------------------
	void CsvData_#CLASS_NAME#::Initialize(void)
	{

	}	
	//-------------------------------------------
    void CsvData_#CLASS_NAME#::ClearData()
    {
		for(tDataMap::iterator iter = m_mData.begin(); iter != m_mData.end(); ++iter)
		{
			for(size_t i = 0; i < iter->second.size(); ++i)
				SAFE_DELETE(iter->second[i]);
		}
		m_mData.clear();
    }
}